Compression is a way to more efficiently store data. It's best explained with a simplified example.
Suppose I have a file that contains the string "aaaaaaaaaaaaaaaaaaaa" (w/o quotes). This is 20 characters of data (or 20 bytes using basic ASCII encoding). If I know that files of this type rarely contain anything other than letters, I could replace this string by "20a" and program my software to read this as an instruction to create a string of 20 a's.
But what happens if I want to use the same function for something that does contain a number? Well, I could decide that any number that is to be interpreted literally, rather than as part of an instruction is preceded by a -symbol (and then add the special case of using \ whenever I want to represent a single ).
In certain cases, where the file doesn't contain many numbers or slashes, the size of the file can be reduced by this shorthand notation. In some special cases, the filesize actually increases due to the rules I introduced to properly represent numbers and slashes.
Next up a compression tool might replace recurring pieces of data by a symbol that takes up considerably less space. Suppose a piece of text contains many instances of a certain word, then the software could replace that word by a single character/symbol. In order to ensure that the decompression software knows what's going on, the file format could be such that it first includes a list of these substitutions, followed by a specific symbol (or combination thereof) that marks the actual content.
A practical example. Lets use both of the previous concepts (replacement of repeated data in a sequence by a number and a single instance of that data and replacement of freqeuntly occurring data by a special symbol and a "dictionary" at the start of the file). We use the format "X=word" at the start of the text to define a substitution of "word" by symbol "X", with the actual text starting with a !. We use the \ to indicate that the following character has no special meaning and should be interpreted literally.
The text is:
I'm going to write Reddit 5 times (RedditRedditRedditRedditReddit) and post it on Reddit.
This line has 90 characters. Applying our compression algorithm, we get:
$=Reddit!I'm going to write $ \5 times (5$) and post it on $.
This line has 62 characters. A reduction of a third. Note that this algorithm is very simplistic and could still be improved.
Another technique that can be used is reducing the size of the alphabet. Using standard ASCII encoding, 1 character uses 1 byte of space, but this 1 byte allows for 256 different characters to be expressed. If I know that a file only contains lowercase letters, I only need 26 different characters, which can be covered with just 5 out of the 8 bits that make up a byte. So for the first character, I don't use the full byte, but rather just the first 5 bits and for the next character, I use 3 remaining bits of the first byte and 2 bits from the next byte, etc...
Now a file like this can only be interpreted correctly if the software on the other end knows it's dealing with a file that uses 5 bits to encode a lowercase letter. This is rather inflexible. So what I can do is to include a special header in the file, a small piece of data that contains the details of the encoding used, in this case it will mention that each character uses 5 bits and then has a list of all the characters that are used. This header takes up some space, so reduces the efficiency of the compression, but it allows the compression software to use any type of character-set that it likes, making it useable for any file.
In reality, ZIP and other compression techniques are considerably more complex than the examples I've demonstrated above. But the basic concepts remains the same: Compression is achieved by storing existing data in a more efficient way using some form of shorthand notation. This shorthand notation is part of the official standard for the compression-system, so developers can create software to follow these rules and correctly decompress a compressed file, recreating the original data.
Just like in my examples, compression works better on some files than on others. A simple text file with a lot of repetition will be very easy to compress, the reduction in file size can be quite large in these cases. On the other hand, a file that contains data that is apparently random in nature will benefit very little, if anything, from compression.
A final remark. All of the above is about "lossless" compression. This form of compression means that the no information is lost during the compression/decompression process. If you compress a file and then decompress it using a lossless algorithm, then the two files will be exactly the same, bit by bit.
Another form of compression is "lossy" compression. Where lossless compression tries to figure out how data can be stored more efficiently, lossy compression tries to figure out what data can be safely discarded without it affecting the purpose of the file. Well known examples of lossy compression are various file formats for images, sound or video.
In the case of images, the JPEG format will try to discard nuances in the image that are not noticable by a regular human observer. For example, if two neighbouring pixels are almost exactly the same colour, you could set both to the same colour value. Most lossy formats have the option to set how aggressive this compression is, which is what the "quality" setting is for when saving JPEG files with any reasonably sophisticated image editor. The more aggressive the compression, the greater the reduction in filesize, but the more data that is discarded. And at some point, this can lead to visible degradation of the image. So-called "JPEG artifacts" are an example of image degradation due to the application of aggressive lossy compression (or the repeat application thereof, the image quality decreases every time a JPEG file is saved).